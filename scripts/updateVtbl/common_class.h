/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'librdi_device.so'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long
#include "common_geometry.h"

typedef uint size_type;
typedef int _Atomic_word;

struct _Rep_base {
  uint64_t vtable_0x0;
  size_type _M_length_0x8;
  size_type _M_capacity_0xc;
  _Atomic_word _M_refcount_0x10; 
};

struct Rep {
   uint64_t vtable_0x0;
  size_type _M_length_0x8;
  size_type _M_capacity_0xc;
  _Atomic_word _M_refcount_0x10;
  //int unknow_0x1c;
 // wchar_t* wchs_0x18;
  
};

struct DList;

struct DListNode {
  int64_t value_0x0;
  DList* parent_list_0x8;
  DListNode* next_0x10;
  DListNode* pre_0x18;
};
struct DList
{
  DListNode *first_0x0;
  DListNode *last_0x8;
  DListNode *current_0x10;
  int64_t size_0x18;
};
/* 9109 */
struct std::string
{
  char* str_0x0;
};
class boost::logic::tribool {
  uint32_t var;
};

class std::iostream {
  uint64_t ios_0x0[33];
};
/* 9110 */
//stack default/s container is deque
//current stack is a deque based stack
class std::stack {
  uint64_t** map_0x0;
  uint64_t size_0x8;
  uint64_t* first_cur_0x10;
  uint64_t* first_start_0x18;
  uint64_t* first_end_0x20;
  uint64_t** first_nod_0x28;
  uint64_t* last_cur_0x30;
  uint64_t* last_start_0x38;
  uint64_t* last_end_0x40;
  uint64_t** last_nod_0x48;
};

class dequeIter {
 int64_t* cur_0x0;
int64_t* first_0x8;
int64_t* last_0x10;
int64_t* node_0x18;
};

class std::deque {
  uint64_t** map_0x0; //2d array
  uint64_t size_0x8;  //
  dequeIter M_start_0x10;
  dequeIter M_finish_0x30;
};

class TemporaryBuf {
uint64_t origin_len_0x0;
uint64_t len_0x8;
uint64_t buffer_0x10;
};
/* 9127 */
struct std::vector1D
{
  int64_t* vector_begin_;
  int64_t* vector_end_;
  int64_t* vector_cap_end_;
};

struct std::vector
{
  int64_t* vector_begin_;
  int64_t* vector_end_;
  int64_t* vector_cap_end_;
};

struct std::vector_bool {
  int64_t* vector_begin_0x0;
  int32_t  inner_i_begin_0x8;
  int32_t  dword_0xc;
  int64_t* vector_end_0x10;
  int32_t  inner_i_end_0x18;
  int32_t  dword_0x1c;
  int64_t* vector_cap_end_0x20;
};

struct HST2DVector_bool {
  std::vector_bool bool_vec_0x0;
  int64_t dim1_size_0x28;
  int64_t dim2_size_0x30;
};

struct Sp_counted_base {
  uint64_t* sp_counted_ptr_vtable_0x0;
  uint32_t weak_count_0x8;
  uint32_t use_count_0xc;
  uint64_t _M_ptr_0x10;
};
struct std::shared_ptr {
  uint64_t* _M_ptr_0x0;
  Sp_counted_base* _M_refcount_0x8;
};

struct std::listNode {
  std::listNode* pre_node_0x0;
  std::listNode* next_node_0x8;
  uint64_t value_0x10;
};

struct std::list {
  std::listNode* pre_node_0x0;
  std::listNode* next_node_0x8;
};

struct std::__detail::_List_node_base {
  std::listNode* pre_node_0x0;
  std::listNode* next_node_0x8;
  uint64_t size_0x10;
};

class HATAttr {
  uint32_t dword_0x0;// 0xffffffff
  uint16_t word_0x4; // 0xffffffff
  uint8_t byte_0x6; // 0x09
  uint8_t byte_0x7; //(inferred)
  uint32_t dword_0x8;// 0x00000000
  uint32_t dword_0xc; //(inferred)
  uint64_t qword_0x10; //[]
};

class std::map { //size = 48 bit
 uint64_t key_compare_0x0_;
 uint64_t end_address_0x8_;
 uint64_t* header_parent_0x10_;
 uint64_t* header_left_0x18_;
 uint64_t* header_right_0x20_;
 uint64_t map_size_0x28_;   //6
};

class std::multimap { //size = 48 bit
 uint64_t key_compare_0x0_;
 uint64_t end_address_0x8_;
 uint64_t* header_parent_0x10_;
 uint64_t* header_left_0x18_;
 uint64_t* header_right_0x20_;
 uint64_t map_size_0x28_;   //6
};

class HSTMultiMap { //size = 48 bit
 uint64_t key_compare_0x0_;
 uint64_t end_address_0x8_;
 uint64_t* header_parent_0x10_;
 uint64_t* header_left_0x18_;
 uint64_t* header_right_0x20_;
 uint64_t map_size_0x28_;   //6
};

class std::mapNode {
 uint64_t* header_color_0x0_;
 uint64_t* header_parent_0x8_;
 uint64_t* header_left_0x10_;
 uint64_t* header_right_0x18_;
 uint64_t* key_0x20_;
 uint64_t* key_or_value_0x28_;
};

class std::mapStrNode {
 uint64_t* header_color_0x0_;
 uint64_t* header_parent_0x8_;
 uint64_t* header_left_0x10_;
 uint64_t* header_right_0x18_;
 std::string str_key_0x20_;
 uint64_t* value_0x28_;
};


class std::set { //size = 48 bit
 uint64_t key_compare_0x0_;
 uint64_t end_address_0x8_;
 uint64_t* header_parent_0x10_;
 uint64_t* header_left_0x18_;
 uint64_t* header_right_0x20_;
 uint64_t set_size_0x28_;   //6
};

class std::setNode {
 uint64_t* header_color_0x0_;
 uint64_t* header_parent_0x8_;
 uint64_t* header_left_0x10_;
 uint64_t* header_right_0x18_;
 uint64_t* key_0x20_;
};

class std::map_unordered { //size = 56 bit
 uint64_t M_buckets_;
 uint64_t M_bucket_count_;
 uint64_t M_before_begin_;
 uint64_t M_element_count_; //4
 uint64_t M_max_load_factor_;
 uint64_t M_next_resize_;
 uint64_t M_single_bucket_;
};

class std::unordered_map { //size = 56 bit
 uint64_t M_buckets_0x0;
 uint64_t M_bucket_count_0x8;
 uint64_t M_before_begin_0x10;
 uint64_t M_element_count_0x18; //4
 uint64_t M_max_load_factor_0x20;
 uint64_t M_next_resize_0x28;
 uint64_t M_single_bucket_0x30;
};

class std::unordered_multimap { //size = 56 bit
 uint64_t M_buckets_0x0;
 uint64_t M_bucket_count_0x8;
 uint64_t M_before_begin_0x10;
 uint64_t M_element_count_0x18; //4
 uint64_t M_max_load_factor_0x20;
 uint64_t M_next_resize_0x28;
 uint64_t M_single_bucket_0x30;
};

class HSTHashMap { //size = 56 bit
 uint64_t M_buckets_0x0;
 uint64_t M_bucket_count_0x8;
 uint64_t M_before_begin_0x10;
 uint64_t M_element_count_0x18; //4
 uint64_t M_max_load_factor_0x20;
 uint64_t M_next_resize_0x28;
 uint64_t M_single_bucket_0x30;
};

class HSTHashMultiMap { //size = 56 bit
 uint64_t M_buckets_0x0;
 uint64_t M_bucket_count_0x8;
 uint64_t M_before_begin_0x10;
 uint64_t M_element_count_0x18; //4
 uint64_t M_max_load_factor_0x20;
 uint64_t M_next_resize_0x28;
 uint64_t M_single_bucket_0x30;
};

class HSTHashSet { //size = 56 bit
 uint64_t M_buckets_0x0;
 uint64_t M_bucket_count_0x8;
 uint64_t M_before_begin_0x10;
 uint64_t M_element_count_0x18; //4
 uint64_t M_max_load_factor_0x20;
 uint64_t M_next_resize_0x28;
 uint64_t M_single_bucket_0x30;
};

class std::unordered_set { //size = 56 bit
 uint64_t M_buckets_0x0;
 uint64_t M_bucket_count_0x8;
 uint64_t M_before_begin_0x10;
 uint64_t M_element_count_0x18; //4
 uint64_t M_max_load_factor_0x20;
 uint64_t M_next_resize_0x28;
 uint64_t M_single_bucket_0x30;
};

class std::ifstream {
  uint64_t vars_0x0[65];
};

class std::ofstream {
  uint64_t vars_0x0[64];
};
class ElementVector {
  uint64_t begin_0x0;
  uint64_t end_0x8;
  uint64_t cap_0x10;
};

class HSTSet { //size = 48 bit
 uint64_t key_compare_0x0_;
 uint64_t end_address_0x8_;
 uint64_t* header_parent_0x10_;
 uint64_t* header_left_0x18_;
 uint64_t* header_right_0x20_;
 uint64_t set_size_0x28_;   //6
};

struct HSTSListNode {
  HSTSListNode* next_node_0x0;
  uint64_t data;
};

struct HSTSList {
  HSTSListNode* next_node_0x0;
  uint64_t data;
};

struct HSTSListStr {
  HSTSListStr* next_node_0x0;
  std::string str_0x8;
};

class HSTVector {
  int64_t* vector_begin_0x0;
  int64_t* vector_end_0x8;
  int64_t vector_cap_0x10;
};

class HSTVector_bool {
  int64_t* vector_begin_0x0;
  int32_t  inner_i_begin_0x8;
  int32_t  dword_0xc;
  int64_t* vector_end_0x10;
  int32_t  inner_i_end_0x18;
  int32_t  dword_0x1c;
  int64_t* vector_cap_end_0x20;
};

class TmIdContainer {
  uint32_t term_id_num_;
  uint32_t term_id_cap_num_;
  uint32_t* term_id_array_;
};

class HDLHIdVector {
  TmIdContainer vector_begin_0x0;
  int64_t* vector_begin_0x10;
  int64_t* vector_end_0x18;
  int64_t vector_cap_0x20;
};

class HST2DVector {
  int64_t* vector_begin_0x0;
  int64_t* vector_end_0x8;
  int64_t vector_cap_0x10;
  int64_t dim1_size_0x18;
  int64_t dim2_size_0x20;
};

struct HST2DVector_bool {
  int64_t* vector_begin_0x0;
  int32_t  inner_i_begin_0x8;
  int32_t  dword_0xc;
  int64_t* vector_end_0x10;
  int32_t  inner_i_end_0x18;
  int32_t  dword_0x1c;
  int64_t* vector_cap_end_0x20;
  int64_t dim1_size_0x28;
  int64_t dim2_size_0x30;
};

struct HSTList { //0x10
  std::listNode* next_node_0x8;
  uint64_t size_0x10;
};

class HSTMap { //size = 48 bit
  uint64_t key_compare_0x0_;
  uint64_t end_address_0x8_;
  uint64_t* header_parent_0x10_;
  uint64_t* header_left_0x18_;
  uint64_t* header_right_0x20_;
  uint64_t map_size_0x28_;   //6
};

class ElementVector {
  uint64_t begin_0x0;
  uint64_t end_0x8;
  uint64_t cap_0x10;
};

class HSTSmartPtrSet {
  std::vector HSTSmartPtrSet_vec_0x0; //T*
  std::unordered_map* HSTSmartPtrSet_un_map_0x20; //T*, int
}; //end of class HSTSmartPtrSet

class HSTSmartPtrMap {
  std::vector HSTSmartPtrMap_vec_0x0; //T*
  std::unordered_map* HSTSmartPtrMap_un_map_0x20; //T*, int
}; //end of class HSTSmartPtrMap

class HSTSmartSet { //Not sure, need to verify
  std::vector HSTSmartPtrSet_vec_0x0; //T*
  std::unordered_map* HSTSmartPtrSet_un_map_0x20; //T*, int
}; //end of class HSTS

class HSTSmartMap { //Not sure, need to verify
  std::vector HSTSmartPtrSet_vec_0x0; //T*
  std::unordered_map* HSTSmartPtrSet_un_map_0x20; //T*, int
}; //end of class HSTS


class pthread_mutex_t {
  uint64_t* qword_0x0;
  uint64_t* qword_0x8;
  uint64_t* qword_0x10;
  uint64_t* qword_0x18;
  uint64_t* qword_0x20;
}; //end of class HSTSm

class HCTMutex {
  uint64_t* qword_0x0;
  uint64_t* qword_0x8;
  uint64_t* qword_0x10;
  uint64_t* qword_0x18;
  uint64_t* qword_0x20;
}; //end of class HSTSm

class tm {
  int tm_sec_0x0;
  int tm_min_0x4;
  int tm_hour_0x8;
  int tm_mday_0x10;
  int tm_mon_0x14;
  int tm_year_0x18;
  int tm_wday_0x20;
  int tm_yday_0x24;
  int tm_isdst_0x28;
  int64_t tm_gmtoff_0x30;
  const char *tm_zone_0x38;
};

typedef bool _BOOL8;
typedef __int128 __OWORD;

union __attribute__((aligned(16))) __m128
{
  float m128_f32[4];
  unsigned __int64 m128_u64[2];
  __int8 m128_i8[16];
  __int16 m128_i16[8];
  __int32 m128_i32[4];
  __int64 m128_i64[2];
  unsigned __int8 m128_u8[16];
  unsigned __int16 m128_u16[8];
  unsigned __int32 m128_u32[4];
};

struct __m128d
{
  double m128d_f64[2];
};

union __attribute__((aligned(16))) __m128i
{
  __int8 m128i_i8[16];
  __int16 m128i_i16[8];
  __int32 m128i_i32[4];
  __int64 m128i_i64[2];
  unsigned __int8 m128i_u8[16];
  unsigned __int16 m128i_u16[8];
  unsigned __int32 m128i_u32[4];
  unsigned __int64 m128i_u64[2];
};

union __attribute__((aligned(32))) __m256
{
  float m256_f32[8];
};

union __attribute__((aligned(32))) __m256d
{
  double m256d_f64[4];
};

union __attribute__((aligned(32))) __m256i
{
  __int8 m256i_i8[32];
  __int16 m256i_i16[16];
  __int32 m256i_i32[8];
  __int64 m256i_i64[4];
  unsigned __int8 m256i_u8[32];
  unsigned __int16 m256i_u16[16];
  unsigned __int32 m256i_u32[8];
  unsigned __int64 m256i_u64[4];
};


class std::random_access_iterator_tag {};
class std::_Rb_tree_node_base {};
class std::integral_constant {};
class std::_Rb_tree_const_iterator {};
class std::_Rb_tree_node {};
class std::_Sp_counted_ptr {};
class std::pair {};
class std::istream {};
class std::ostream {};
class std::_Fwd_list_const_iterator {};
class std::function {};
class std::_List_const_iterator {};

/*
class std::_Ios_Seekdir {}
class std::_Ios_Openmode {}
class std::codecvt {}
class std::deque {}
class std::bad_alloc {}
class std::bad_exception {}
class std::ostreambuf_iterator {}
class std::locale::facet {}
class std::auto_ptr {}
class std::fpos {}
class std::thread::_State {}
class std::domain_error {}
*/

class std::auto_ptr {
};
class std::fpos {
};
class std::_Ios_Seekdir {
};
class std::_Ios_Openmode {
};
class std::ostreambuf_iterator {
};
class std::istreambuf_iterator {
};


struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int64_t tm_gmtoff;
  const char *tm_zone;
};

/* 130 */
struct lconv {
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};
class std::ios_base::_Words {
  void *_M_pword;
  long _M_iword;
};
class std::basic_stringstream { //size = 0x170
  void* basic_istream_vtable0_0x0;
  long _M_gcount_0x8;
  void* basic_ostream_vtable2_0x10;
  void* basic_streambuf_vtable3_0x18;
  char* _M_in_beg_0x20;
  char* _M_in_cur_0x28;
  char* _M_in_end_0x30; 
  char* _M_out_beg_0x38; 
  char* _M_out_cur_0x40; 
  char* _M_out_end_0x48; 
  void* std_local_0x50; //std::locale
  int std__Ios_Openmode_0x58;
  std::string _M_string_0x60;
  void* ios_base_vtable0_0x68;
  long _M_precision_0x70;
  long _M_width_0x78;
  int std_Ios_Fmtflags_M_flags_0x80;
  int std_Ios_Iostate_M_exception_0x84; 
  int std_Ios_Iostate_M_streambuf_state_0x88; 
  void* _M_callbacks_0x90; //std::ios_base::_Callback_list*
  long _M_word_zero_M_pword_0x98; // = {_M_pword = 0x0, _M_iword = 0x0}, 
  long _M_word_zero_M_iword_A0;
  std::ios_base::_Words _M_local_word_0xA8[8]; //size = 0x80              
  int _M_word_size_0x128;
  std::ios_base::_Words* _M_word_0x130;
  uint64_t _M_ios_locale_0x138; //std::locale
};

